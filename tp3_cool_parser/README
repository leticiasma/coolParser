                    Arquivo README para o Trabalho Prático 3
================================================================================

Estrutura
---------

  Considere que <cool dir> corresponde ao caminho onde está a pasta "cool" que
  você extraiu do arquivo "tp3-4.tar.gz". Após executar o comando

  > make -f <cool dir>/assignments/parser/Makefile

  seu diretório deve conter os seguintes arquivos (-> corresponde a links
  simbólicos):

  Makefile                -> [cool dir]/src/parser/Makefile
  README
  cool.y
  bad.cl
  good.cl
  cool-tree.handcode.h
  cool-tree.cc            -> [cool dir]/src/parser/cool-tree.cc
  cool-tree.aps           -> [cool dir]/src/parser/cool-tree.aps
  dumptype.cc             -> [cool dir]/src/parser/dumptype.cc
  handle_flags.c          -> [cool dir]/src/parser/handle_flags.cc
  parser-phase.cc         -> [cool dir]/src/parser/parser-phase.cc
  stringtab.cc            -> [cool dir]/src/parser/stringtab.cc
  tokens-lex.cc           -> [cool dir]/src/parser/tokens-lex.cc
  tree.cc                 -> [cool dir]/src/parser/tree.cc
  utilities.cc            -> [cool dir]/src/parser/utilities.cc
  *.d                     dependency files
  *.*                     other generated files

  Os arquivos de cabeçalho (.h) para este trabalho podem ser encontrados em
  [cool dir]/include/parser.

  O Makefile contém ações para compilar e executar seu programa.
  NÃO MODIFIQUE.

  O README (este arquivo) contém algumas instruções. Além disso, você encontrará
  ao final do arquivo um espaço para que você preencha a documentação a ser
  entregue. Você deve explicar as decisões de projeto, explicar por que seu
  programa está correto e por que seus casos de teste são adequados. Ao final,
  antes de gerar o arquivo de submissão, apague todo o conteúdo do arquivo README
  que não faz parte da sua documentação (i.e. as instruções aqui presentes, acima
  dos dizeres "corte aqui"),

  cool.y contém um esqueleto inicial da especificação do parser que você irá
  escrever. Ele já contém algumas produções para programa e classes. Use-as como
  exemplo para escrever o restante das produções. Você deve, também, ler a
  documentação do bison.

  good.cl e bad.cl testam algumas características da gramática. Você deve
  adicionar testes para garantir que good.cl exercite qualquer construção legal e
  que bad.cl exercite a maior quantidade possível de erros que você consiga
  inserir em um único arquivo.

  cool-tree.aps contém as definições de árvore que você utilizará para construir
  a árvore de sintaxe abstrata (AST). A partir deste arquivo, cool-tree.h e
  cool-tree.cc são gerados automaticamente por um utilitário que compila a
  especificação para funções C++, para produzir e consumir nós de árvore.
  NÃO MODIFIQUE.

  tree.{cc|h} contém definições usadas pelo pacote de árvore.
  cool-tree.handcode.h é uma extensão de cool-tree.h escrita a mão. Se você ler
  os arquivos cool-tree.h e cool-tree.cc, você notará que existem "hooks" para
  estender declarações de classes. Estender e moficar o pacote de árvore é
  discutido em "Cool Tour", mas você não precisa modificar esse
  pacote para este trabalho.

  tokens-lex.cc é um analisador léxico capaz de ler uma sequência de tokens.
  NÃO MODIFIQUE.

  parser-phase.cc contém um driver para testar o parser. NÃO MODIFIQUE.

  dumptype.cc imprime a AST em um formato legível para a fase de análise
  semântica do compilador. NÃO MODIFIQUE.

  handle_flags.cc implementa rotinas para analisar opções passadas por linha de
  comando. NÃO MODIFIQUE.

  O restante dos arquivos são gerados pelo bison.
  cool-parse.cc é o arquivo C++ gerado que contém a implementação do parser.

Instruções
----------

  Para compilar seu parser, execute o seguinte comando:

  > make parser

  Isto irá produzer um executável chamado "parser", que corresponde somente a
  fase de análise sintática do compilador. Para fazer qualquer coisa útil, será
  necessário o analisador léxico (executável = lexer), semântico (executável =
  semant) e geração de código (executável = cgen).

  Para testar seu parser em um arquivo "foo.cl", execute o
  seguinte comando:

  > ./myparser foo.cl

  myparser é um arquivo shell script que une os analisadores léxico e
  sintático.

  Para aplicar seu parser aos arquivos good.cl e bad.cl, execute o comando:

  > make dotest

  Se você acredita que seu parser está correto, você pode querer
  rodar o compilador Cool completo. Para tanto, execute o
  seguinte comando:

  > ./mycoolc foo.cl -o foo.s

  mycoolc é um arquivo shell script que une as fases de compilação (léxico,
  sintático, semântico e geração de código). Você tem disponível
  também o coolc, uma versão de referência do compilador de
  Cool, caso queira utilizar:

  > ./coolc foo.cl -o foo.s

  E, caso queira testar o programa gerado, você pode utilizar o
  emulador spim:

  > ./spim -file foo.s

  Para entregar seu trabalho, primeiro certifique-se que está tudo funcionando
  e que você preencheu o arquivo README corretamente. Em seguida, dentro do
  diretório do projeto, execute o seguinte comando (considerando que apenas
  os arquivos a seguir foram modificados):

  > tar -czvf tp3_seuNOME.tar.gz cool.y good.cl bad.cl README

  BOA SORTE!

------8<------8<------8<------8<---corte arqui---8<------8<------8<------8<-----

Daniel Souza de Campos ; 2018054664
Letícia da Silva Macedo Alves ; 2018054443

TP3 - Compiladores

Decisões:
-Para implementar as regras dos não terminais, seguimos as regras apresentadas na seção 12 do cool-manual.pdf
-Para implementar as declarações de precedência usamos o que foi especificado na seção 11.1 do cool-manual.pdf
-Assumimos para o erro na definição de classe que uma classe é considerada encerrada corretamente se sua
definição termina com "};"

Casos de teste adicionados:
-Em good.cl escrevemos um programa que exercita todas as construções (direta ou indiretamente) permitidas pela
gramática. O código base utilizado foi a classe A2I do arquivo cool/examples/atoi.cl. Esta classe englobava a maioria 
das regras, porém, foi necessário escrever a classe Main com o método main() que adicinou o uso das demais regras que 
ainda não haviam sido cobertas pela classe A2I.
-Em bad.cl os erros que focamos em tratar foram apenas aqueles especificados na documentação. Ou seja: erro na definição
 de classe (que é encerrada corretamente e a próxima classe está sintáticamente correta), erros em features (movendo 
 para a próxima feature), em uma declaração em uma expressão let (movendo para a próxima variável) ou em uma expressão 
 dentro de um bloco. Todos esses 4 tipos de erro, portanto, foram exercitados no programa escrito em bad.cl.

Como testamos:
-Usamos como casos de teste os programas disponibilizados em cool/examples e também nosso good.cl. Para os testes, nós
compilamos os programas com o comando "./mycoolc foo.cl -o foo.s" e executamos através do emulador spim utilizando o 
comando "./spim -file foo.s". Não houveram erros de compilação e as execuções ocorreram como o esperado.
-Além disso, a fim de verificar se o nosso Parser fornecia como saída a AST (árvore de sintaxe abstrata) correta, 
utilizamos o comando "./myparser foo.cl" para gerar a AST usando nosso Parser e comparamos essa saída com a gerada por
"./lexer teste.cl | caminho/para/tp4/parser" utilizando um site para comparação de textos (https://www.diffchecker.com/diff).

Porque acreditamos que o programa está correto: 
Acreditamos que nosso programa esteja correto pois, em cool.cl, implementamos todas as declarações de precedência, 
completamos a lista de não terminais da gramática juntamente com seus tipos e implementamos também todas as regras
de tipo que especificam a sintaxe de Cool (apresentadas na seção 12 do cool-manual.pdf). Nosso Parser passou em todos 
os casos de testes em cool/examples e também no arquivo good.cl que escrevemos (como detalhado na seção anterior).
Além disso, tratamos e exercitamos os erros mencionados na seção 5 da especificação.